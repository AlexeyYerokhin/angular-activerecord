(function(angular, undefined) {
	'use strict';
	angular.module('ActiveRecord', ['ng']).factory('ActiveRecord', function($http, $q) {
		/**
		 * @class ActiveRecord
		 * @constructor
		 * @param {Object} [properties]  Initialize the record with these property values.
		 */
		var ActiveRecord = function ActiveRecord (properties) {
			this.$initialize.apply(this, arguments);
		};
		ActiveRecord.prototype = {
			/**
			 * @property {string}
			 */
			$idAttribute: 'id',

			/**
			 * Contructor logic
			 * (which is called by autogenerated contructors via ActiveRecord.extend)
			 * @param {Object} [properties]  Initialize the record with these property values.
			 */
			$initialize: function (properties) {
				if (this.$defaults) {
					angular.extend(this, this.$defaults);
				}
				if (properties) {
					angular.extend(this, properties);
				}
			},
			/**
			 * (re)load data from the backend.
			 * @param {Object} [options] sync options
			 * @return $q.promise
			 */
			$fetch: function (options) {
	      		return this.$sync('read', this, options);
			},
			/**
			 * Save the record to the backend.
			 * @param {Object} [values] Set these values before saving the record.
			 * @param {Object} [options] sync options
			 * @return $q.promise
			 */
			$save: function (values, options) {
				if (values) {
					angular.extend(this, values);
				}
				if (this[this.$idAttribute]) {
					return this.$sync('update', this, options);
				}
				return this.$sync('create', this, options);
			},
			/**
			 * Remove the record from the backend.
			 * @param {Object} [options] sync options
			 * @return $q.promise
			 */
			$destroy: function (options) {
				return this.$sync('delete', this, options);	
			},
			/**
			 * 
			 */
			$url: function() {
	      		if (typeof this[this.$idAttribute] === 'undefined') {
	      			return this.$urlRoot;
	      		}
	      		return this.$urlRoot + (this.$urlRoot.charAt(this.$urlRoot.length - 1) === '/' ? '' : '/') + encodeURIComponent(this[this.$idAttribute]);
	      		
	    	},
			/**
			 * Process the data from the response and return the record-properties.
			 * @param {Object} data  The data from the sync response.
			 * @param {Object} [options] sync options
			 * @return $q.promise
			 */
			$parse: function (data, options) {
				return data;
			},
			/**
			 * The counterpart to $parse.
	    	 * Don't call this method directly, this method is called by JSON.stringify.
	    	 * Override it to filter or cast the properties for use in json.
	    	 */
	    	toJSON: function () {
	    		return this;
	    	},
	    	
	    	/**
			 * By default calls ActiveRecord.sync
			 * Override to change the backend implementation on a per model bases.
			 */
			$sync: function (operation, model, options) {
				return ActiveRecord.sync.apply(this, arguments);
			}
		};

		ActiveRecord.sync = function (operation, model, options) {
			if (typeof options === 'undefined') {
				options = {};
			}
			if (!options.method) {
				var crudMapping = {
					create: 'POST',
					read: 'GET',
					update: 'PUT',
					delete: 'DELETE'
				};
				options.method = crudMapping[operation];
			}
			if (!options.url) {
				options.url = model.$url();
			}
			if (operation === 'create' || operation === 'update') {
				options.data = model;
			}
			var defer = $q.defer();
			var request = $http(options);
			return request.then(function (response) {
				if (response.data) {
					angular.extend(model, model.$parse(response.data, options));
				}
				return model;
			});
		};

		ActiveRecord.extend = function(protoProps, staticProps) {
	    	var parent = this;
	    	var child;
	 
		    if (protoProps && typeof protoProps.$constructor === 'function') {
		      child = protoProps.$constructor;
	    	} else {
		      child = function () { return parent.apply(this, arguments); };
		    }
		    angular.extend(child, parent, staticProps);
	    	var Surrogate = function () { this.$constructor = child; };
	    	Surrogate.prototype = parent.prototype;
	    	child.prototype = new Surrogate;
		    if (protoProps) {
		    	angular.extend(child.prototype, protoProps); 
		    }
		    child.__super__ = parent.prototype;
	    	return child;
		};

		/**
		 * Load a single record.
		 *
		 * @param {Mixed} id
		 * @param {Object} [options]
		 * @return $q.promise
		 */
		ActiveRecord.fetchOne = function (id, options) {
			var model = new this();
			model[model.$idAttribute] = id;
			return model.$fetch(options);
		};

		return ActiveRecord;
	});
})(window.angular);